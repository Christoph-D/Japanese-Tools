#!/bin/bash
# Copyright: Christoph Dittmann <eigene_homepage@gmx.de>
# License: GNU GPL, version 3 or later; http://www.gnu.org/copyleft/gpl.html
#
# Hiragana and katakana trainer.

if [ -z "$KANA_FILE" ]; then
    echo "Please don't call this script directly, use $(dirname "$0")/hira or $(dirname "$0")/kata instead."
    exit 1
fi

SOLUTION_FILE="$DIRECTORY/solution.txt" # this file will be overwritten
LESSON_STATUS_FILE="$DIRECTORY/status.txt" # this file will be overwritten
USER_STATS_DIR="$DIRECTORY/user_statistics" # this directory will be filled with files
USER=$DMB_SENDER

DEFAULT_RESULT_ITEMS=5
MAX_RESULT_ITEMS=30
LESSON_MAP=( 5 10 15 20 25 30 35 38 43 45 46 ) # line numbers in $KANA_FILE

# Make sure we have a UTF-8 environment.
LANG=en_US.UTF-8
# Preliminary checks
if [[ ! -e $KANA_FILE ]]; then
   echo 'Please fix $KANA_FILE.'
   exit 1
fi
# Cache kana file so we don't need to read it over and over again.
KANA_SRC=$(cat "$KANA_FILE")
if [[ ! -d $USER_STATS_DIR ]]; then
   echo 'Please point $USER_STATS_DIR to an existing directory.'
   exit 2
fi
if [[ -z $USER ]]; then
    echo 'Could not determine nick name. Please fix $USER.'
    exit 1
fi

# Prints the smaller of the two arguments.
min() { if (( "$1" < "$2" )); then echo "$1"; else echo "$2"; fi; }

show_help() {
    # It's a German irc bot. The help message in English reads
    # "Start with \"$IRC_COMMAND <level> [count]\"."
    # "Known levels are 0 to $(( ${#LESSON_MAP[*]} - 1))."
    # "To learn more about some level please use \"$IRC_COMMAND help <level>\"."
    # "To only see the differences between consecutive levels, please
    # use \"$IRC_COMMAND helpdiff <level>\"."
    echo -n "Beginnen mit \"$IRC_COMMAND <Stufe> [Anzahl]\". "
    echo -n "Bekannte Stufen sind 0 bis $(( ${#LESSON_MAP[*]} - 1)). "
    echo "Für Erklärung einer Stufe bitte \"$IRC_COMMAND help <Stufe>\" eingeben."
    echo "Um nur die neuen Zeichen einer Stufe anzuzeigen bitte \"$IRC_COMMAND helpdiff <Stufe>\" verwenden."
}

# Parameters: Lesson number
# Result:     The lesson and only the current lesson on stdout.
read_single_lesson() {
    if (( "$1" >= ${#LESSON_MAP[*]} )); then
        # If the lesson number is outside the valid range, don't print
        # anything.
        return
    fi

    local LESSON_LINES_START=0
    if (( "$1" > 0 )); then
        LESSON_LINES_START=${LESSON_MAP[$(( $1 - 1 ))]}
    fi
    echo "$KANA_SRC" | head -n ${LESSON_MAP[$1]} | tail -n +$(( $LESSON_LINES_START + 1))
}
# Parameters: Lesson number
# Result:     The lessons 0 to $1 on stdout.
read_lesson() {
    local UPTO=$(min "$1" "${#LESSON_MAP[*]}")
    for I in $(seq 0 $UPTO); do
        read_single_lesson "$I"
    done
}
# Parameters: Lesson number
# Result:     The lessons 0 to $1 on stdout. Each lesson may
#             appear multiple times in a row. See the
#             implementation for the general formula.
read_weighted_lessons() {
    local UPTO=$(min "$1" "${#LESSON_MAP[*]}")
    local COUNT=1
    for I in $(seq 0 $UPTO); do
        local L=$(read_single_lesson "$I")
        for J in $(seq 0 $COUNT); do
            echo "$L"
        done
        if (( $UPTO - $I < 5 )); then
            let "COUNT = COUNT * 2"
        fi
    done
}

#read_weighted_lessons $1
#exit 0

# Parameters: lesson-number result-lines
start_lesson() {
    RESULT_LINES=$2
    # Sanitize $RESULT_LINES
    if echo "$RESULT_LINES" | grep -q -v -E '^[0-9]+$'; then
        RESULT_LINES=$DEFAULT_RESULT_ITEMS
    elif (( $RESULT_LINES < 1 )); then
        RESULT_LINES=1
    elif (( $RESULT_LINES > $MAX_RESULT_ITEMS )); then
        RESULT_LINES=$MAX_RESULT_ITEMS
    fi
    # Generate the lesson, i.e. shuffle it and restrict it to
    # $RESULT_LINES lines.
    LESSON=$(read_weighted_lessons "$1" | shuf | head -n "$RESULT_LINES")

    KANA=$(echo "$LESSON" | cut -d ' ' -f 1)
    KANA=${KANA//$'\n'/ }

    echo "Leseübung: $KANA"
    echo "$LESSON" > "$SOLUTION_FILE"
    # Save the status so we can generate a similar question again
    # after this one has been answered.
    echo "$1 $RESULT_LINES" > "$LESSON_STATUS_FILE"
}
# Result: $USER_STATS
read_user_statistics() {
    USER=${USER////} # remove slashes
    USER=${USER//./} # remove dots
    USER_FILE="$USER_STATS_DIR"/"$USER"
    if [[ -f $USER_FILE ]]; then
        USER_STATS=( $(cat "$USER_FILE") )
    else
        USER_STATS=( 0 0 )
    fi
}
# Paramaters: $USER_STATS
print_user_statistics() {
    if (( ${USER_STATS[1]} > 0 )); then
        local PERCENT=$(echo "scale=2; ${USER_STATS[0]} * 100 / ${USER_STATS[1]}" | bc)
        echo "Statistik für $USER: $PERCENT% von ${USER_STATS[1]} Zeichen korrekt."
    else
        echo "Keine Statistik für $USER vorhanden."
    fi
}

if [[ $* = "help" ]]; then
    show_help
    exit 0
fi

QUERY=( $@ )
if [[ ${QUERY[0]} = "stats" ]]; then
    if [[ -n ${QUERY[1]} ]]; then
        USER=${QUERY[1]}
    fi
    read_user_statistics
    print_user_statistics
    exit 0
fi

QUERY_BEGIN="${QUERY[0]} ${QUERY[1]}"
if echo "$QUERY_BEGIN" | grep -q -E '^help [0-9]+$'; then
    # Lesson help
    LESSON=$(read_lesson "${QUERY[1]}")
    LESSON=${LESSON// /=}
    echo "${LESSON//$'\n'/ }"
    exit 0
elif echo "$QUERY_BEGIN" | grep -q -E '^helpdiff [0-9]+$'; then
    # Lesson helpdiff
    LESSON_DIFF=$(read_single_lesson "${QUERY[1]}")
    LESSON_DIFF=${LESSON_DIFF// /=}
    LESSON_DIFF=${LESSON_DIFF//$'\n'/ }
    if [ -n "$LESSON_DIFF" ]; then
        echo "$LESSON_DIFF"
    else
        echo "Kein Diff verfügbar. :-("
    fi
    exit 0
fi

if echo "$QUERY_BEGIN" | grep -q -E '^[0-9]+ [0-9]*$'; then
    start_lesson "${QUERY[0]}" "${QUERY[1]}"
    exit 0
fi

if [[ ! -f "$SOLUTION_FILE" ]]; then
    show_help
    exit 0
elif find "$SOLUTION_FILE" -maxdepth 0 -mmin +60 | grep -q -e '.'; then
    # Solution file is too old, discard it.
    rm "$SOLUTION_FILE"
    show_help
    exit 0
fi

SOLUTION=( $(cut -d ' ' -f 2 "$SOLUTION_FILE") )
KANA_SOLUTION=( $(cut -d ' ' -f 1 "$SOLUTION_FILE") )
EXPECTED_NUMBER=${#SOLUTION[*]}
rm "$SOLUTION_FILE"

CORRECT=0
PRETTY_SOLUTION=
for I in $(seq 0 $(( $EXPECTED_NUMBER - 1 ))); do
    EXPECTED=${SOLUTION[$I]}
    GOT=${QUERY[$I]}
    if [[ $EXPECTED = $GOT ]]; then
        let "++CORRECT"
    else
        PRETTY_SOLUTION="$PRETTY_SOLUTION ${KANA_SOLUTION[$I]}=$EXPECTED"
    fi
done
if (( $CORRECT == 0 )); then
    echo -n "Leider kein einziges Zeichen korrekt. Lösung:$PRETTY_SOLUTION. "
elif (( $CORRECT == $EXPECTED_NUMBER )); then
    echo -n "Alles korrekt! $CORRECT von $EXPECTED_NUMBER. "
else
    echo -n "Korrekt: $CORRECT von $EXPECTED_NUMBER, Korrekturen:$PRETTY_SOLUTION. "
fi

# update user statistics
read_user_statistics
USER_STATS[0]=$(( ${USER_STATS[0]} + $CORRECT ))
USER_STATS[1]=$(( ${USER_STATS[1]} + $EXPECTED_NUMBER ))
print_user_statistics
echo "${USER_STATS[*]}" > "$USER_FILE"

# Start new lesson.
if [[ -f $LESSON_STATUS_FILE ]]; then
    # Note: No quoting here because start_lesson expects 2 parameters.
    start_lesson $(cat "$LESSON_STATUS_FILE")
fi

exit 0
